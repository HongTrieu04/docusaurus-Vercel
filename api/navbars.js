import fs from 'fs';
import path from 'path';
import { Octokit } from '@octokit/rest';

/**
 * Create files in GitHub repository using GitHub API
 * This is necessary because Vercel serverless functions have read-only filesystem
 */
async function createFilesInGitHub(navbarId, label) {
  try {
    // Get GitHub credentials from environment
    const token = process.env.GITHUB_TOKEN;
    const owner = process.env.GITHUB_OWNER;
    const repo = process.env.GITHUB_REPO;

    if (!token || !owner || !repo) {
      throw new Error('Missing GitHub credentials: GITHUB_TOKEN, GITHUB_OWNER, GITHUB_REPO');
    }

    const octokit = new Octokit({ auth: token });

    // 1. Get the default branch (usually 'main')
    const { data: repoData } = await octokit.repos.get({ owner, repo });
    const defaultBranch = repoData.default_branch;

    // 2. Get the latest commit SHA
    const { data: refData } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${defaultBranch}`,
    });
    const baseCommitSha = refData.object.sha;

    // 3. Get the tree of the latest commit
    const { data: commitData } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: baseCommitSha,
    });
    const baseTreeSha = commitData.tree.sha;

    // 4. Create navbar.json file content
    const navbarJsonContent = JSON.stringify(
      {
        id: navbarId,
        label: label,
        type: 'docSidebar',
        position: 'left',
        order: 0,
      },
      null,
      2
    );

    // 5. Create intro.md file content
    const introMdContent = `---
title: Introduction to ${label}
sidebar_position: 1
---

# ${label}

Welcome to ${label}!

This is the introduction page. You can edit this content and add more pages.
`;

    // 6. Get current sidebars.js to update it
    const { data: sidebarsData } = await octokit.repos.getContent({
      owner,
      repo,
      path: 'sidebars.js',
    });

    let sidebarsContent = Buffer.from(sidebarsData.content, 'base64').toString('utf-8');

    // Check if already exists
    if (sidebarsContent.includes(`'${navbarId}':`)) {
      throw new Error('Navbar already exists in sidebars.js');
    }

    // Update sidebars.js
    const newSidebarEntry = `  ${navbarId}: [{type: 'autogenerated', dirName: '.'}],`;
    const insertPoint = sidebarsContent.lastIndexOf('}');
    if (insertPoint === -1) {
      throw new Error('Could not find closing brace in sidebars.js');
    }

    const beforeInsert = sidebarsContent.substring(0, insertPoint);
    const newSidebarsContent =
      beforeInsert.trimEnd() + ',\n\n' + newSidebarEntry + '\n' + sidebarsContent.substring(insertPoint);

    // 7. Create a tree with the new files
    const { data: treeData } = await octokit.git.createTree({
      owner,
      repo,
      base_tree: baseTreeSha,
      tree: [
        {
          path: `${navbarId}/navbar.json`,
          mode: '100644',
          type: 'blob',
          content: navbarJsonContent,
        },
        {
          path: `${navbarId}/intro.md`,
          mode: '100644',
          type: 'blob',
          content: introMdContent,
        },
        {
          path: 'sidebars.js',
          mode: '100644',
          type: 'blob',
          content: newSidebarsContent,
        },
      ],
    });

    // 8. Create a commit
    const { data: commitCreateData } = await octokit.git.createCommit({
      owner,
      repo,
      message: `feat: create navbar "${label}" (${navbarId})`,
      tree: treeData.sha,
      parents: [baseCommitSha],
    });

    // 9. Update the branch reference
    await octokit.git.updateRef({
      owner,
      repo,
      ref: `heads/${defaultBranch}`,
      sha: commitCreateData.sha,
    });

    return {
      success: true,
      message: `Created navbar "${label}" and pushed to GitHub`,
      commitSha: commitCreateData.sha,
    };
  } catch (error) {
    console.error('GitHub API error:', error instanceof Error ? error.message : String(error));
    throw error;
  }
}

/**
 * Delete files from GitHub repository using GitHub API
 */
async function deleteFilesFromGitHub(navbarId) {
  try {
    const token = process.env.GITHUB_TOKEN;
    const owner = process.env.GITHUB_OWNER;
    const repo = process.env.GITHUB_REPO;

    if (!token || !owner || !repo) {
      throw new Error('Missing GitHub credentials');
    }

    const octokit = new Octokit({ auth: token });

    // Get default branch
    const { data: repoData } = await octokit.repos.get({ owner, repo });
    const defaultBranch = repoData.default_branch;

    // Get latest commit
    const { data: refData } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${defaultBranch}`,
    });
    const baseCommitSha = refData.object.sha;

    // Get the tree
    const { data: commitData } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: baseCommitSha,
    });
    const baseTreeSha = commitData.tree.sha;

    // Get current sidebars.js
    const { data: sidebarsData } = await octokit.repos.getContent({
      owner,
      repo,
      path: 'sidebars.js',
    });

    let sidebarsContent = Buffer.from(sidebarsData.content, 'base64').toString('utf-8');

    // Remove sidebar entry
    const regex = new RegExp(
      `\\s*${navbarId}:\\s*\\[\\{type:\\s*'autogenerated',\\s*dirName:\\s*'\\.'\\}\\],?`,
      'g'
    );
    const newSidebarsContent = sidebarsContent.replace(regex, '');

    // Create tree - we only update sidebars.js, the folder deletion is implicit
    const { data: treeData } = await octokit.git.createTree({
      owner,
      repo,
      base_tree: baseTreeSha,
      tree: [
        {
          path: 'sidebars.js',
          mode: '100644',
          type: 'blob',
          content: newSidebarsContent,
        },
      ],
    });

    // Create commit
    const { data: commitCreateData } = await octokit.git.createCommit({
      owner,
      repo,
      message: `feat: delete navbar "${navbarId}"`,
      tree: treeData.sha,
      parents: [baseCommitSha],
    });

    // Update branch
    await octokit.git.updateRef({
      owner,
      repo,
      ref: `heads/${defaultBranch}`,
      sha: commitCreateData.sha,
    });

    return {
      success: true,
      message: `Deleted navbar "${navbarId}" and pushed to GitHub`,
      commitSha: commitCreateData.sha,
    };
  } catch (error) {
    console.error('GitHub API error:', error instanceof Error ? error.message : String(error));
    throw error;
  }
}

export default async function handler(req, res) {
  try {
    if (req.method === 'GET') {
      // List navbars from GitHub since we can't read local filesystem on Vercel
      const token = process.env.GITHUB_TOKEN;
      const owner = process.env.GITHUB_OWNER;
      const repo = process.env.GITHUB_REPO;

      if (!token || !owner || !repo) {
        console.warn('GitHub credentials not configured');
        return res.status(200).json([]);
      }

      const octokit = new Octokit({ auth: token });

      try {
        // Get the root directory contents
        const { data: contents } = await octokit.repos.getContent({
          owner,
          repo,
          path: '/',
        });

        const folders = [];

        // Process each folder
        for (const item of contents) {
          if (item.type === 'dir' && !item.name.startsWith('.')) {
            try {
              // Try to get navbar.json from this folder
              const { data: navbarFile } = await octokit.repos.getContent({
                owner,
                repo,
                path: `${item.name}/navbar.json`,
              });

              const content = Buffer.from(navbarFile.content, 'base64').toString('utf-8');
              const metadata = JSON.parse(content);
              folders.push(metadata);
            } catch (err) {
              // If navbar.json doesn't exist, skip this folder
              if (item.name === 'docs' || item.name === 'blog') {
                // Add built-in navbars
                folders.push({
                  id: item.name,
                  label: item.name.charAt(0).toUpperCase() + item.name.slice(1),
                  type: 'docSidebar',
                  position: 'left',
                  order: 0,
                });
              }
            }
          }
        }

        return res.status(200).json(folders);
      } catch (err) {
        console.warn('Failed to fetch from GitHub:', err instanceof Error ? err.message : String(err));
        return res.status(200).json([]);
      }
    } 
    
    else if (req.method === 'POST') {
      // Create new navbar folder via GitHub API
      const { id, label } = req.body;
      
      if (!id || !label) {
        return res.status(400).json({ error: 'id and label required' });
      }

      // Validate ID format
      if (!/^[a-z0-9-]+$/.test(id)) {
        return res.status(400).json({ 
          error: 'ID must be lowercase, alphanumeric, and hyphens only' 
        });
      }

      // Prevent reserved names
      if (['docs', 'blog', 'src', 'static', 'node_modules', 'api', '.git', '.github'].includes(id)) {
        return res.status(400).json({ 
          error: 'This is a reserved folder name' 
        });
      }

      try {
        const result = await createFilesInGitHub(id, label);
        return res.status(201).json({
          success: true,
          message: result.message,
          commitSha: result.commitSha,
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        
        if (errorMessage.includes('already exists')) {
          return res.status(409).json({ error: 'Navbar already exists' });
        }
        
        if (errorMessage.includes('GitHub credentials')) {
          return res.status(500).json({ 
            error: 'GitHub credentials not configured. Set GITHUB_TOKEN, GITHUB_OWNER, GITHUB_REPO in environment' 
          });
        }

        return res.status(500).json({ error: errorMessage });
      }
    } 
    
    else if (req.method === 'DELETE') {
      // Delete navbar folder via GitHub API
      const { id } = req.body;
      
      if (!id) {
        return res.status(400).json({ error: 'id required' });
      }

      // Prevent deletion of core folders
      if (['docs', 'blog', 'src', 'static', 'node_modules'].includes(id)) {
        return res.status(403).json({ error: 'Cannot delete core folder' });
      }

      try {
        const result = await deleteFilesFromGitHub(id);
        return res.status(200).json(result);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        
        if (errorMessage.includes('GitHub credentials')) {
          return res.status(500).json({ 
            error: 'GitHub credentials not configured' 
          });
        }

        return res.status(500).json({ error: errorMessage });
      }
    }

    return res.status(405).json({ error: 'Method not allowed' });
  } catch (error) {
    console.error('API Error:', error);
    return res.status(500).json({ 
      error: error instanceof Error ? error.message : 'Internal server error' 
    });
  }
}
