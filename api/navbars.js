import fs from 'fs';
import path from 'path';

/**
 * Update sidebars.js to include the new navbar sidebar config
 */
function updateSidebarsConfig(projectRoot, navbarId) {
  try {
    const sidebarsPath = path.join(projectRoot, 'sidebars.js');
    
    if (!fs.existsSync(sidebarsPath)) {
      console.warn('sidebars.js not found');
      return;
    }

    let content = fs.readFileSync(sidebarsPath, 'utf8');
    
    // Check if this navbar ID already exists in sidebars
    if (content.includes(`'${navbarId}':`)) {
      console.log(`${navbarId} already in sidebars.js`);
      return;
    }

    // Add the new sidebar entry before the closing brace
    const newSidebarEntry = `  ${navbarId}: [{type: 'autogenerated', dirName: '.'}],`;
    
    // Find the closing brace of the sidebars object and insert before it
    const insertPoint = content.lastIndexOf('}');
    if (insertPoint === -1) {
      console.warn('Could not find closing brace in sidebars.js');
      return;
    }

    // Get the indentation from the previous line
    const beforeInsert = content.substring(0, insertPoint);
    const newContent = beforeInsert.trimEnd() + ',\n\n' + newSidebarEntry + '\n' + content.substring(insertPoint);
    
    fs.writeFileSync(sidebarsPath, newContent);
    console.log(`Updated sidebars.js with ${navbarId}`);
  } catch (err) {
    console.error('Failed to update sidebars.js:', err instanceof Error ? err.message : String(err));
  }
}

/**
 * Remove sidebar entry from sidebars.js when navbar is deleted
 */
function removeSidebarEntry(projectRoot, navbarId) {
  try {
    const sidebarsPath = path.join(projectRoot, 'sidebars.js');
    
    if (!fs.existsSync(sidebarsPath)) {
      console.warn('sidebars.js not found');
      return;
    }

    let content = fs.readFileSync(sidebarsPath, 'utf8');
    
    // Remove the sidebar entry for this navbar
    const regex = new RegExp(`\\s*${navbarId}:\\s*\\[\\{type:\\s*'autogenerated',\\s*dirName:\\s*'\\.'\\}\\],?`, 'g');
    const newContent = content.replace(regex, '');
    
    fs.writeFileSync(sidebarsPath, newContent);
    console.log(`Removed ${navbarId} from sidebars.js`);
  } catch (err) {
    console.error('Failed to update sidebars.js:', err instanceof Error ? err.message : String(err));
  }
}

export default async function handler(req, res) {
  const projectRoot = process.cwd();
  
  try {
    if (req.method === 'GET') {
      // List all navbar folders
      const navbarsPath = projectRoot;
      const entries = fs.readdirSync(navbarsPath);
      
      const folders = entries
        .filter(name => {
          const fullPath = path.join(navbarsPath, name);
          try {
            const stat = fs.statSync(fullPath);
            return stat.isDirectory() && !name.startsWith('.') && name !== 'node_modules';
          } catch {
            return false;
          }
        })
        // Filter only navbar-like folders (docs, blog, and custom ones)
        .filter(name => {
          const metaPath = path.join(navbarsPath, name, 'navbar.json');
          return fs.existsSync(metaPath) || ['docs', 'blog'].includes(name);
        })
        .map(folderName => {
          const metaPath = path.join(navbarsPath, folderName, 'navbar.json');
          let metadata = {
            id: folderName,
            label: folderName.charAt(0).toUpperCase() + folderName.slice(1),
            type: 'docSidebar',
            position: 'left',
            order: 0,
          };

          if (fs.existsSync(metaPath)) {
            try {
              const content = fs.readFileSync(metaPath, 'utf8');
              metadata = JSON.parse(content);
            } catch (err) {
              console.warn(`Failed to parse ${metaPath}:`, err.message);
            }
          }

          return metadata;
        });

      return res.status(200).json(folders);
    } 
    
    else if (req.method === 'POST') {
      // Create new navbar folder
      const { id, label } = req.body;
      
      if (!id || !label) {
        return res.status(400).json({ error: 'id and label required' });
      }

      const navbarPath = path.join(projectRoot, id);
      
      // Check if folder already exists
      if (fs.existsSync(navbarPath)) {
        return res.status(409).json({ error: 'Navbar already exists' });
      }

      // Create folder
      fs.mkdirSync(navbarPath, { recursive: true });

      // Create navbar.json metadata file
      const metadata = {
        id,
        label,
        type: 'docSidebar',
        position: 'left',
        order: 0,
      };

      fs.writeFileSync(
        path.join(navbarPath, 'navbar.json'),
        JSON.stringify(metadata, null, 2)
      );

      // Create intro.md file
      const introPath = path.join(navbarPath, 'intro.md');
      const introContent = `---
title: Introduction to ${label}
sidebar_position: 1
---

# ${label}

Welcome to ${label}!

This is the introduction page. You can edit this content and add more pages.
`;

      fs.writeFileSync(introPath, introContent);

      // Update sidebars.js to include the new navbar
      updateSidebarsConfig(projectRoot, id);

      return res.status(201).json({
        success: true,
        message: `Created navbar folder: ${id}`,
        metadata,
      });
    } 
    
    else if (req.method === 'DELETE') {
      // Delete navbar folder
      const { id } = req.body;
      
      if (!id) {
        return res.status(400).json({ error: 'id required' });
      }

      const navbarPath = path.join(projectRoot, id);

      if (!fs.existsSync(navbarPath)) {
        return res.status(404).json({ error: 'Navbar not found' });
      }

      // Prevent deletion of core folders
      if (['docs', 'blog', 'src', 'static', 'node_modules'].includes(id)) {
        return res.status(403).json({ error: 'Cannot delete core folder' });
      }

      // Delete folder recursively
      fs.rmSync(navbarPath, { recursive: true, force: true });

      // Remove from sidebars.js
      removeSidebarEntry(projectRoot, id);

      return res.status(200).json({ success: true, message: `Deleted navbar: ${id}` });
    }

    return res.status(405).json({ error: 'Method not allowed' });
  } catch (error) {
    console.error('API Error:', error);
    return res.status(500).json({ 
      error: error instanceof Error ? error.message : 'Internal server error' 
    });
  }
}
